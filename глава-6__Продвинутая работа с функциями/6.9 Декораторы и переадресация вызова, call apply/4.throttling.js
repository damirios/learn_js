// Тормозящий (throttling) декоратор

// Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку, 
// передавая вызов в f не более одного раза в ms миллисекунд. 
// Те вызовы, которые попадают в период «торможения», игнорируются.

// Отличие от debounce – если проигнорированный вызов является последним во время «задержки», то он выполняется в конце.

// Давайте рассмотрим реальное применение, чтобы лучше понять это требование и выяснить, откуда оно взято.

// Например, мы хотим отслеживать движения мыши.

// В браузере мы можем объявить функцию, которая будет запускаться при каждом движении 
// указателя и получать его местоположение. 
// Во время активного использования мыши эта функция запускается очень часто, 
// это может происходить около 100 раз в секунду (каждые 10 мс).

// Мы бы хотели обновлять информацию на странице при передвижениях.

// …Но функция обновления update() слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. 
// Да и нет смысла делать обновление чаще, чем один раз в 1000 мс.

// Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 1000) как функцию, 
// которая будет запускаться при каждом перемещении указателя вместо оригинальной update(). 
// Декоратор будет вызываться часто, но передавать вызов в update() максимум раз в 1000 мс.

// Визуально это будет выглядеть вот так:

// 1. Для первого движения указателя декорированный вариант сразу передаёт вызов в update. 
// Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.

// 2. Затем, когда указатель продолжает движение, в течение 1000 мс ничего не происходит. Декорированный вариант игнорирует вызовы.

// 3. По истечению 1000 мс происходит ещё один вызов update с последними координатами.

// 4. Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт, пока не истечёт 1000 мс, 
// и затем вызывает update с последними координатами. В итоге окончательные координаты указателя тоже обработаны.

// Пример кода:
let timer = Date.now();
function f(a) {
    console.log('time: ', Date.now() - timer);
    console.log(a)
}

// f1000 передаёт вызовы f максимум раз в 1000 мс
let f1000 = throttle(f, 1000);
f1000(1); // показывает 1
f1000(2); // (ограничение, 1000 мс ещё нет)
setTimeout(() => f1000(3), 1000);

setTimeout(() => f1000(4), 100); // (задержка - менее 1000 мс с момента последнего вызова)
setTimeout(() => f1000(5), 100); // (задержка - менее 1000 мс с момента последнего вызова)
setTimeout(() => f1000(6), 700); // (задержка - менее 1000 мс с момента последнего вызова)

// когда 1000 мс истекли ...
// ...выводим 3, промежуточное значение 2 было проигнорировано
// P.S. Аргументы и контекст this, переданные в f1000, должны быть переданы в оригинальную f.

function throttle(func, ms) {
    let isReady = true;
    let lastArgs;
    let lastThis;
    function wrapper(...args) {
        console.log('called: ', ...args);
        console.log('timer: ', Date.now() - timer);
        if (isReady) {
            isReady = false;
            setTimeout(() => {
                isReady = true;
                if (lastArgs) {
                    wrapper.apply(lastThis, lastArgs);
                    lastArgs = null;
                    lastThis = null;
                }
            }, ms);

            func.apply(this, args);
        } else {
            lastArgs = args;
            lastThis = this;
        }
    }

    return wrapper;
}